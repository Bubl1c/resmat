#include "std_lib_facilities.h"
#include <cmath>
#include <stdio.h>
int main()
{
int na,nb;//номер закріплення 0 -вільний край, 1-шарнір, 2-жорстке
int m;// кількість точок розбиття пластини
double lenth_a, lenth_b, height_h, modul_E, koef_Puas;// геометричні характеристики та матеріал, вводяться ззовні

double f_a, f_b, m_a, m_b, fi_a, fi_b, w_a, w_b,q1;

// навантаження на внутрішньому 
//та зовнішньому контурі та вимушені переміщення
double del_t,d_e;
na=1;
nb=2;
m=11;
lenth_a=0.1;
lenth_b=1.1;
height_h=0.002;
modul_E=200000000.0;
koef_Puas=0.3;
f_a=0.;
f_b=0.;
m_a=0.;
m_b=0.;
fi_a=0.;
fi_b=0.;
w_a=0.01;
w_b=0.;
q1=0.;
//початок програми
// визначення кроку розбиття
del_t=(lenth_b-lenth_a)/(m-1);
cout<<del_t<<"\n";
d_e=pow(height_h,3)*modul_E/12./(1.-pow(koef_Puas,2));
cout<<d_e<<"\n";
// вектор координат точек
vector<double> r1(m);
   r1[0]=lenth_a;
for (int i=1;i<m; ++i){
	r1[i]=r1[i-1]+del_t;}
for (int j=0;j<m; ++j){
	cout<<"v["<<j<<"]=="<<r1[j]<<"\n";}
// формування системи рівнянь в залежності від гран умов
 double g1[4][5];
 vector<double> b2(4);
// контур а пластини!!!!!!------------------------------------------------------
// якщо вільний край
 if(na==0){
// перше рівняння системи
	if(w_a==0.){
	 g1[0][0]=-4.*d_e/r1[0];
	 g1[0][1]=0.;
	 g1[0][2]=0.;
	 g1[0][3]=0.;
	 g1[0][4]=q1*r1[0]/2.+f_a;}
	else {
	 g1[0][0]=pow(r1[0],2)*log(r1[0]);
	 g1[0][1]=pow(r1[0],2);
	 g1[0][2]=log(r1[0]);
	 g1[0][3]=1.;
	 g1[0][4]=q1*pow(r1[0],4)/64./d_e+w_a;}

// друге рівняння системи 
	if(fi_a==0.){
	 g1[1][0]=-d_e*(2.*(1.+koef_Puas)*log(r1[0])+3.+koef_Puas);
	 g1[1][1]=-2.*d_e*(1.+koef_Puas);
	 g1[1][2]=-d_e*(koef_Puas-1.)/pow(r1[0],2);
	 g1[1][3]=0.;
	 g1[1][4]=q1*(3.+koef_Puas)*pow(r1[0],2)/16.+m_a;}
	else {
	 g1[1][0]=2.*r1[0]*log(r1[0])+r1[0];
	 g1[1][1]=2.*r1[0];
	 g1[1][2]=1./r1[0];
	 g1[1][3]=0.;
	 g1[1][4]=-q1*pow(r1[0],3)/16./d_e+fi_a;}
 }

 // якщо шарнір
 if(na==1) {
// перше рівняння системи
 if(fi_a==0.){
       g1[0][0]=-d_e*(2.*(1.+koef_Puas)*log(r1[0])+3.+koef_Puas);
       g1[0][1]=-2.*d_e*(1.+koef_Puas);
       g1[0][2]=-d_e*(koef_Puas-1.)/pow(r1[0],2);
       g1[0][3]=0.;
	   g1[0][4]=q1*(3.+koef_Puas)*pow(r1[0],2)/16.+m_a;}
       else{
       g1[0][0]=2.*r1[0]*log(r1[0])+r1[0];
       g1[0][1]=2.*r1[0];
       g1[0][2]=1./r1[0];
       g1[0][3]=0.;
       g1[0][4]=-q1*pow(r1[0],3)/16./d_e+fi_a;
	   }
// друге рівняння системи 
       g1[1][0]=pow(r1[0],2)*log(r1[0]);
       g1[1][1]=pow(r1[0],2);
       g1[1][2]=log(r1[0]);
       g1[1][3]=1.;
       g1[1][4]=-q1*pow(r1[0],4)/64./d_e+w_a;
 }
 // якщо жорстке защемлення
 if(na==2){
	   g1[0][0]=pow(r1[0],2)*log(r1[0]);
       g1[0][1]=pow(r1[0],2);
       g1[0][2]=log(r1[0]);
       g1[0][3]=1.;
       g1[0][4]=-q1*pow(r1[0],4)/64./d_e+w_a;
      
       g1[1][0]=2.*r1[0]*log(r1[0])+r1[0];
       g1[1][1]=2.*r1[0];
        g1[1][2]=1./r1[0];
        g1[1][3]=0.;
        g1[1][4]=-q1*pow(r1[0],3)/16./d_e+fi_a;
 }


 // вільний край
  if(nb==0){
// 3 рівняння системи
	if(w_b==0.){
	 g1[2][0]=-4.*d_e/r1[m-1];
	 g1[2][1]=0.;
	 g1[2][2]=0.;
	 g1[2][3]=0.;
	 g1[2][4]=q1*r1[m-1]/2.+f_b;}
	else {
	 g1[2][0]=pow(r1[m-1],2)*log(r1[m-1]);
	 g1[2][1]=pow(r1[m-1],2);
	 g1[2][2]=log(r1[m-1]);
	 g1[2][3]=1.;
	 g1[2][4]=q1*pow(r1[m-1],4)/64./d_e+w_b;
// 4 рівняння системи 
	if(fi_b==0.){
	 g1[3][0]=-d_e*(2.*(1.+koef_Puas)*log(r1[m-1])+3.+koef_Puas);
	 g1[3][1]=-2.*d_e*(1.+koef_Puas);
	 g1[3][2]=-d_e*(koef_Puas-1.)/pow(r1[m-1],2);
	 g1[3][3]=0.;
	 g1[3][4]=q1*(3.+koef_Puas)*pow(r1[m-1],2)/16.+m_b;}
	else {
	 g1[3][0]=2.*r1[m-1]*log(r1[m-1])+r1[m-1];
	 g1[3][1]=2.*r1[m-1];
	 g1[3][2]=1./r1[m-1];
	 g1[3][3]=0.;
	 g1[3][4]=-q1*pow(r1[m-1],3)/16./d_e+fi_b;}
 }
  }
 //якщо шарнір
// трерє рівняння системи
 if(nb==1){
		if(fi_b==0.){
       g1[2][0]=-d_e*(2.*(1.+koef_Puas)*log(r1[m-1])+3.+koef_Puas);
       g1[2][1]=-2.*d_e*(1.+koef_Puas);
       g1[2][2]=-d_e*(koef_Puas-1.)/pow(r1[m-1],2);
       g1[2][3]=0.;
	   g1[2][4]=q1*(3.+koef_Puas)*pow(r1[m-1],2)/16.+m_b;}
       else{
       g1[2][0]=2.*r1[m-1]*log(r1[m-1])+r1[m-1];
       g1[2][1]=2.*r1[m-1];
       g1[2][2]=1./r1[m-1];
       g1[2][3]=0.;
       g1[2][4]=-q1*pow(r1[m-1],3)/16./d_e+fi_b;
	   }
//     четверте рівняння системи
       g1[3][0]=pow(r1[m-1],2)*log(r1[m-1]);
       g1[3][1]=pow(r1[m-1],2);
       g1[3][2]=log(r1[m-1]);
       g1[3][3]=1.;
	   g1[3][4]=-q1*pow(r1[m-1],4)/64./d_e+w_b;
 }
	 
 // якщо жорстке защемлення
 if(nb==2){
	   g1[2][0]=pow(r1[m-1],2)*log(r1[m-1]);
       g1[2][1]=pow(r1[m-1],2);
       g1[2][2]=log(r1[m-1]);
       g1[2][3]=1.;
       g1[2][4]=-q1*pow(r1[m-1],4)/64./d_e+w_b;
      
       g1[3][0]=2.*r1[m-1]*log(r1[m-1])+r1[m-1];
       g1[3][1]=2.*r1[m-1];
        g1[3][2]=1./r1[m-1];
        g1[3][3]=0.;
        g1[3][4]=-q1*pow(r1[m-1],3)/16./d_e+fi_b;
 }	  
//Розвязання системи рівнянь 4 на 4 методом Гауса
//-----------------------------------------------------------------------
 double  tmp;
    int k,i,j;
	int n=4;
 
    for (i=0; i<n; i++)
     {
       tmp=g1[i][i];
         for (j=n;j>=i;j--)
             g1[i][j]/=tmp;
           for (j=i+1;j<n;j++)
          {
             tmp=g1[j][i];
               for (k=n;k>=i;k--)
             g1[j][k]-=tmp*g1[i][k];
          }
      }
  /*обратный ход*/
    b2[n-1] = g1[n-1][n];
     for (i=n-2; i>=0; i--)
       {
           b2[i] = g1[i][n];
           for (j=i+1;j<n;j++) b2[i]-=g1[i][j]*b2[j];
       }

	 cout<<"b2="<<"\n";
	 for(int i = 0; i < 4; i ++) {
 printf ("%f", b2[i] );
   printf("\n");
}
//-------------------------------------------------------------------------  
// b2-вектор х-ів
// Визначення функцій переміщень та зусиль для кожної точки розбиття
 vector<double> w_1(m),fi_1(m),mr_1(m),mt_1(m),qr_1(m); 
	 for(int i = 0; i < m; i ++)
	 {
      w_1[i]=b2[0]*(r1[i])*(r1[i])*log(r1[i])+b2[1]*(r1[i])*(r1[i])+b2[2]*log(r1[i])+b2[3]+q1*pow(r1[i],4)/d_e/64.;
      fi_1[i]=b2[0]*(2.*r1[i]*log(r1[i])+r1[i])+2.*b2[1]*r1[i]+b2[2]/r1[i]+q1*pow(r1[i],3)/d_e/16.;
      mr_1[i]=-d_e*(2.*(1.+koef_Puas)*log(r1[i])+3.+koef_Puas)*b2[0]-2.*d_e*(1.+koef_Puas)*b2[1]-d_e*(koef_Puas-1.)/pow(r1[i],2)*b2[2]-q1*(3.+koef_Puas)*pow(r1[i],2)/16.;
      mt_1[i]=-d_e*(2.*(1.+koef_Puas)*log(r1[i])+3.*koef_Puas+1.)*b2[0]-2.*d_e*(1.+koef_Puas)*b2[1]-d_e*(-koef_Puas+1.)/pow(r1[i],2)*b2[2]-q1*(3.*koef_Puas+1.)*pow(r1[i],2)/16.;
	 qr_1[i]=-4.*d_e/r1[i]*b2[0]-q1*r1[i]/2.;
	 }
   
//вивод результатів на екран
	 cout<<"w_1="<<"\n";
	 for(int i = 0; i < m; i ++) {
 printf ("%f", w_1[i] );
   printf("\n");
}
	 cout<<"fi_1="<<"\n";
	for(int i = 0; i < m; i ++) {
 printf ("%f", fi_1[i] );
   printf("\n");
}
cout<<"mr_1="<<"\n";
		 for(int i = 0; i < m; i ++) {
 printf ("%f", mr_1[i] );
   printf("\n");
}
cout<<"mt_1="<<"\n";
		 	 for(int i = 0; i < m; i ++) {

 printf ("%f", mt_1[i] );
   printf("\n");
}
cout<<"qr_1="<<"\n";
			 	 for(int i = 0; i < m; i ++) {
 printf ("%f", qr_1[i] );
   printf("\n");
}
// визначеня екстремальний напржень
 vector<double> g_r(m),g_t(m),t_t(m);;
	for(int i=0; i<m; i++){
		g_r[i]=6.*mr_1[i]/pow(height_h,2);
	g_t[i]=6.*mt_1[i]/pow(height_h,2);
	t_t[i]=-3./2.*qr_1[i]/height_h;
	}
 cout<<"g_r="<<"\n";
	 for(int i = 0; i < m; i ++) {
 printf ("%f", g_r[i] );
   printf("\n");
}
	  cout<<"g_t="<<"\n";
	 for(int i = 0; i < m; i ++) {
 printf ("%f", g_t[i] );
   printf("\n");
}
	  cout<<"t_t="<<"\n";
	 for(int i = 0; i < m; i ++) {
 printf ("%f", t_t[i] );
   printf("\n");
}
keep_window_open();
}